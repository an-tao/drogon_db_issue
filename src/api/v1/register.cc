/**
 *
 *  register.cc
 *  This file is generated by drogon_ctl
 *
 */

#include "register.h"
#include <string>

using namespace drogon;
using namespace drogon::orm;
using namespace api::v1;

void registration::doRegister(const HttpRequestPtr &req,
                              std::function<void(const HttpResponsePtr &)> &&callback)
{
    auto json = req->getJsonObject();
    Json::Value ret;

    auto name = json->get("name", "").asString();
    auto email = json->get("email", "").asString();
    auto username = json->get("username", "").asString();
    auto password = json->get("password", "").asString();

    LOG_DEBUG << "name: " << name;
    LOG_DEBUG << "email: " << email;
    LOG_DEBUG << "username: " << username;
    LOG_DEBUG << "password: " << password;

    // always validate user input. never rely on what is coming from the other side
    if (name == "" || username == "" || email == "" || password == "")
    {
        ret["error"] = "None of the fields can be empty.";
        auto resp = HttpResponse::newHttpJsonResponse(ret);
        callback(resp);
    }

    // {
    auto clientPtr = app().getFastDbClient("default");
    assert(clientPtr);
    *clientPtr << "select * from users"
               >>
        [](const Result &r) {
            LOG_DEBUG << r.size();
        } >>
        [](const DrogonDbException &e) {
            LOG_DEBUG << e.base().what();
        };
    // clientPtr->newTransactionAsync([ret = ret, username = username, callback = callback](const std::shared_ptr<Transaction> &transPtr) {
    //     std::cerr << "grrrr"<<std::endl;
    // LOG_DEBUG << "Starting transaction.";
    // transPtr->execSqlAsync(
    //     "select * from users where username=$1",
    //     [=](const Result &r) {
    //         LOG_DEBUG << r.size();
    // if (r.size() < 0)
    // {
    //     LOG_DEBUG << "Inseting data";
    //     *transPtr << "insert into users(username) values('$1')"
    //               << username >>
    //         [=](const Result &r) mutable {
    //             ret["username"] = username;
    //             auto resp = HttpResponse::newHttpJsonResponse(ret);
    //             callback(resp);
    //         } >>
    //         [=](const DrogonDbException &e) mutable {
    //             LOG_ERROR << "err:" << e.base().what();
    //             ret["error"] = "Exception occured during transaction.";
    //             auto resp = HttpResponse::newHttpJsonResponse(ret);
    //             callback(resp);
    //         };
    // }
    // else
    // {
    //     LOG_ERROR << "No new tasks found!";
    //     ret["error"] = "username already exists";
    //     auto resp = HttpResponse::newHttpJsonResponse(ret);
    //     callback(resp);
    // }
    // },
    // [](const DrogonDbException &e) {
    //     // LOG_ERROR << "err:" << e.base().what();
    //     // ret["error"] = "Exception occured during transaction.";
    //     // auto resp = HttpResponse::newHttpJsonResponse(ret);
    //     // callback(resp);
    // },
    // username);
    // });
    // }
}
